# 优化请求依赖图分支布局

## 目标
修改树布局算法，使分叉时**较长的分支保留在原列**，**较短的分支分到新列**，实现更协调的视觉效果。

## 当前行为
- 子节点按时间戳排序，第一个子节点（最早）保留原列
- 问题：较短但较早的分支占据主列，导致布局不协调

## 实现方案

### 修改文件
`viewer/src/components/sidebar/RequestGraph.tsx`

### 具体改动

1. **添加计算子树大小的辅助函数**
```typescript
function getSubtreeSize(node: RequestTreeNode): number {
  let size = 1; // 当前节点
  for (const child of node.children) {
    size += getSubtreeSize(child);
  }
  return size;
}
```

2. **修改 `assignCols` 函数中的分支逻辑**

原代码（第 42-51 行）：
```typescript
if (node.children.length > 0) {
  node.children.forEach((child, i) => {
    if (i === 0) {
      assignCols(child, col, false, counter, node.request.id, out);
    } else {
      const newCol = counter.value++;
      assignCols(child, newCol, true, counter, node.request.id, out);
    }
  });
}
```

修改为：
```typescript
if (node.children.length > 0) {
  // 按子树大小降序排序，最大的子树保留原列
  const sortedChildren = [...node.children].sort(
    (a, b) => getSubtreeSize(b) - getSubtreeSize(a)
  );

  sortedChildren.forEach((child, i) => {
    if (i === 0) {
      assignCols(child, col, false, counter, node.request.id, out);
    } else {
      const newCol = counter.value++;
      assignCols(child, newCol, true, counter, node.request.id, out);
    }
  });
}
```

### 性能优化（可选）
如果树结构很大，可以缓存子树大小避免重复计算：
```typescript
const subtreeSizeCache = new Map<string, number>();

function getSubtreeSize(node: RequestTreeNode): number {
  const cached = subtreeSizeCache.get(node.request.id);
  if (cached !== undefined) return cached;

  let size = 1;
  for (const child of node.children) {
    size += getSubtreeSize(child);
  }
  subtreeSizeCache.set(node.request.id, size);
  return size;
}
```

## 验证方法
1. 运行 `cd viewer && npm run dev` 启动开发服务器
2. 加载包含分叉的 trace 数据
3. 观察分叉点：较长的分支应该保持在原列，较短的分支应该分到新列
4. 检查视觉效果是否更协调

## 影响范围
- 仅影响 `RequestGraph.tsx` 中的列分配逻辑
- 不影响其他组件或数据结构
- 向后兼容，无需修改数据格式
